typedef struct {
    void *out;
    const char *output_filename;
    const char *zig_lib_dir;
    uint8_t indent;
    Ctx *ctx;

    char *zig_h;
    long zig_h_len;
} CodeGen;

static void CodeGen_init(CodeGen *cg, Ctx *ctx, const char *output_filename, const char *zig_lib_dir)
{
    cg->ctx = ctx;
    cg->out = std_createFile(output_filename);
    cg->indent = 0;
    if (!cg->out) std_panic(NULL, "failed to fopen output\n");

    size_t zig_lib_dir_len = std_strlen(zig_lib_dir);
    assume(zig_lib_dir_len + 1 + 5 + 1 < 512);

    char joined[512];
    std_memcpy(joined, zig_lib_dir, zig_lib_dir_len);
    size_t len = zig_lib_dir_len;
    joined[len++] = '/';
    std_memcpy(joined + len, "zig.h", 5);
    joined[len] = 0;

    cg->zig_h = std_readFile(joined, &cg->zig_h_len);
    if (!cg->zig_h) std_panic(NULL, "failed to open %s\n", joined);
}

__attribute__((format(printf, 2, 3)))
static int CodeGen_emit(CodeGen *cg, const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    int result = std_vfprintf(cg->out, fmt, args);
    va_end(args);
    return result;
}

static int CodeGen_indent(CodeGen *cg)
{
    return std_fprintf(cg->out, "%*c", 4 * cg->indent, ' ');
}

static void CodeGen_emitPrologue(CodeGen *cg)
{
    CodeGen_emit(cg, "/* Generated by tzc */\n");
#ifdef USE_ZIG_H
    CodeGen_emit(cg, "\n");
    CodeGen_emit(cg, "#define ZIG_TARGET_MAX_INT_ALIGNMENT 16\n");
    CodeGen_emit(cg, "/* zig.h begin */\n");
    std_writeFile(cg->zig_h, cg->zig_h_len, 1, cg->out);
    CodeGen_emit(cg, "/* zig.h end */\n");
    CodeGen_emit(cg, "\n");
#else
    CodeGen_emit(cg, "#include <stddef.h>\n");
    CodeGen_emit(cg, "#include <stdbool.h>\n");
    CodeGen_emit(cg, "#include <stdint.h>\n");
    CodeGen_emit(cg, "\n");
#endif
}

static void CodeGen_emitType(CodeGen *cg, tInternId id)
{
    tType ty = Ctx_getType(cg->ctx, id);
    switch (ty.tag) {
        case ty_anyopaque:
            CodeGen_emit(cg, "void");
            break;
        case ty_bool:
            CodeGen_emit(cg, "_Bool");
            break;
        case ty_u8:
            CodeGen_emit(cg, "uint8_t");
            break;
        case ty_u16:
            CodeGen_emit(cg, "uint16_t");
            break;
        case ty_u32:
            CodeGen_emit(cg, "uint32_t");
            break;
        case ty_u64:
            CodeGen_emit(cg, "uint64_t");
            break;
        case ty_u128:
            CodeGen_emit(cg, "unsigned __int128");
            break;
        case ty_i8:
            CodeGen_emit(cg, "int8_t");
            break;
        case ty_i16:
            CodeGen_emit(cg, "int16_t");
            break;
        case ty_i32:
            CodeGen_emit(cg, "int32_t");
            break;
        case ty_i64:
            CodeGen_emit(cg, "int64_t");
            break;
        case ty_i128:
            CodeGen_emit(cg, "int128_t");
            break;
        case ty_isize:
            CodeGen_emit(cg, "ssize_t");
            break;
        case ty_usize:
            CodeGen_emit(cg, "size_t");
            break;
        case ty_c_char:
            CodeGen_emit(cg, "char");
            break;
        case ty_c_short:
            CodeGen_emit(cg, "short");
            break;
        case ty_c_ushort:
            CodeGen_emit(cg, "unsigned short");
            break;
        case ty_c_int:
            CodeGen_emit(cg, "int");
            break;
        case ty_c_uint:
            CodeGen_emit(cg, "unsigned int");
            break;
        case ty_c_long:
            CodeGen_emit(cg, "long");
            break;
        case ty_c_ulong:
            CodeGen_emit(cg, "unsigned long");
            break;
        case ty_c_longlong:
            CodeGen_emit(cg, "long long");
            break;
        case ty_c_ulonglong:
            CodeGen_emit(cg, "unsigned long long");
            break;
        case ty_c_longdouble:
            CodeGen_emit(cg, "long double");
            break;
        case ty_f16:
            CodeGen_emit(cg, "_Float16");
            break;
        case ty_f32:
            CodeGen_emit(cg, "float");
            break;
        case ty_f64:
            CodeGen_emit(cg, "double");
            break;
        case ty_f80:
            CodeGen_emit(cg, "long double");
            break;
        case ty_f128:
            CodeGen_emit(cg, "__Float128");
            break;
        // complex
        case ty_ptr_one:
            if ((ty.data.ptr.modifiers & pointer_modifier_const) != 0) CodeGen_emit(cg, "const ");
            CodeGen_emitType(cg, ty.data.ptr.child);
            CodeGen_emit(cg, "*");
            break;
        case ty_ptr_two:
            if ((ty.data.ptr.modifiers & pointer_modifier_const) != 0) CodeGen_emit(cg, "const ");
            CodeGen_emitType(cg, ty.data.ptr.child);
            CodeGen_emit(cg, "**");
            break;
        default:
            assume(false);
    }
}

static void CodeGen_emitFuncDecl(CodeGen *cg, IrFunc *func)
{
    CodeGen_emit(cg, "int "PRIb"(", Ctx_Buffer(cg->ctx, func->name));

    if (func->call_args.len == 0) {
        CodeGen_emit(cg, "void");
    } else {
        for (uint32_t i = 0; i < func->call_args.len; i++) {
            IrNamedType ty = func->call_args.data[i];
            if (!ty.is_varargs) {
                CodeGen_emitType(cg, ty.type);
                CodeGen_emit(cg, " "PRIb, Ctx_Buffer(cg->ctx, ty.name));
            } else {
                CodeGen_emit(cg, "...");
            }
            if (i + 1 < func->call_args.len) CodeGen_emit(cg, ", ");
        }
    }
    CodeGen_emit(cg, ")");
}

static void CodeGen_emitInst(CodeGen *cg, IrFunc *func, IrInst inst)
{
    CodeGen_indent(cg);

    IrTemp dst;
    if (IrOp_hasDst(inst.op)) dst = func->temps.data[inst.dst];

    switch (inst.op) {
        case ir_op_call:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = "PRIb"(", inst.dst, Ctx_Buffer(cg->ctx, inst.data.call.fn.data.sym));
            for (uint8_t i = 0; i < inst.data.call.args_len; i++) {
                CodeGen_emit(cg, "t%d", inst.data.call.args[i]);
                if (i + 1 < inst.data.call.args_len) CodeGen_emit(cg, ",");
            }
            CodeGen_emit(cg, ");\n");
            break;

        case ir_op_copy:
            CodeGen_emit(cg, "t%d = t%d;\n", inst.dst, inst.data.unary.lhs);
            break;

        case ir_op_negate:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = -t%d;\n", inst.dst, inst.data.unary.lhs);
            break;
        case ir_op_bw_not:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = ~t%d;\n", inst.dst, inst.data.unary.lhs);
            break;
        case ir_op_bw_and:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = &t%d;\n", inst.dst, inst.data.unary.lhs);
            break;
        case ir_op_not:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = !t%d;\n", inst.dst, inst.data.unary.lhs);
            break;

        case ir_op_const_num:
        case ir_op_const_char:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = %lld;\n", inst.dst, inst.data.i64);
            break;

        case ir_op_store_var:
            CodeGen_emit(cg, "v%d = t%d;\n", inst.data.var.id, inst.data.var.value);
            break;
        case ir_op_load_var:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = v%d;\n", inst.dst, inst.data.var.id);
            break;

        case ir_op_const_bytes:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = "PRIb";\n", inst.dst, Ctx_Buffer(cg->ctx, inst.data.bytes));
            break;

        case ir_op_or:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d || t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_and:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d && t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_eq:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d == t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_neq:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d != t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_lt:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d < t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_gt:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d > t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_lte:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d <= t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_gte:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d >= t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_bit_and:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d & t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_bit_xor:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d ^ t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_shl:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d << t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_shr:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d >> t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_add:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d + t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_sub:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d - t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_mul:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d * t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_div:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d / t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_mod:
            CodeGen_emitType(cg, dst.type);
            CodeGen_emit(cg, " t%d = t%d %% t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;

        default:
            break;
    }
}

static void CodeGen_emitTerm(CodeGen *cg, IrTerm term)
{
    CodeGen_indent(cg);
    switch (term.tag) {
        case ir_term_br:
            CodeGen_emit(cg, "if (t%d) { goto b%d; } else { goto b%d; }\n",
                term.data.br.cond, term.data.br.t, term.data.br.f);
            break;

        case ir_term_jmp:
            CodeGen_emit(cg, "goto b%d;\n", term.data.jmp.target);
            break;

        case ir_term_ret:
            CodeGen_emit(cg, "return t%d;\n", term.data.ret.value);
        case ir_term_next:
            break;
    }
}

static void CodeGen_emitBlock(CodeGen *cg, IrFunc *func, IrBlockId id, IrBlock *block)
{
    // jump targets can be empty, hence emit an empty statement unconditionally
    CodeGen_emit(cg, "b%d:;\n", id);
    for (uint32_t i = 0; i < block->insts.len; i++) {
        CodeGen_emitInst(cg, func, block->insts.data[i]);
    }
    CodeGen_emitTerm(cg, block->term);
}

static void CodeGen_emitFuncDef(CodeGen *cg, IrFunc *func)
{
    CodeGen_emitFuncDecl(cg, func);
    CodeGen_emit(cg, "\n{\n");

    for (uint32_t i = 0; i < func->vars.len; i++) {
        CodeGen_indent(cg);
        CodeGen_emitType(cg, func->vars.data[i].type);
        CodeGen_emit(cg, " v%d", i);
        if (func->vars.data[i].init_name != ir_invalid_id) {
            CodeGen_emit(cg, " = "PRIb, Ctx_Buffer(cg->ctx, func->vars.data[i].init_name));
        }
        CodeGen_emit(cg, "; // "PRIb"\n", Ctx_Buffer(cg->ctx, func->vars.data[i].name));
    }

    for (uint32_t i = 0; i < func->blocks.len; i++) {
        CodeGen_emitBlock(cg, func, i, func->blocks.data[i]);
    }

    CodeGen_emit(cg, "}\n\n");
}

static void CodeGen_emitModule(CodeGen *cg, IrProgram *ir)
{
    CodeGen_emitPrologue(cg);

    for (uint32_t i = 0; i < ir->funcs.len; i++) {
        CodeGen_emitFuncDecl(cg, ir->funcs.data[i]);
        CodeGen_emit(cg, ";\n");
    }
    CodeGen_emit(cg, "\n");

    for (uint32_t i = 0; i < ir->funcs.len; i++) {
        if ((ir->funcs.data[i]->modifiers & decl_modifier_extern) != 0) {
            continue;
        }

        CodeGen_emitFuncDef(cg, ir->funcs.data[i]);
    }
}

static void CodeGen_gen(CodeGen *cg, IrProgram *ir)
{
    CodeGen_emitModule(cg, ir);
}