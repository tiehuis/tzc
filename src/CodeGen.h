typedef struct {
    void *out;
    const char *output_filename;
    const char *zig_lib_dir;
    uint8_t indent;
    Parser *p;

    char *zig_h;
    long zig_h_len;
} CodeGen;

static void CodeGen_init(CodeGen *cg, const char *output_filename, const char *zig_lib_dir)
{
    cg->out = std_createFile(output_filename);
    cg->indent = 0;
    if (!cg->out) std_panic(NULL, "failed to fopen output\n");

    size_t zig_lib_dir_len = std_strlen(zig_lib_dir);
    assume(zig_lib_dir_len + 1 + 5 + 1 < 512);

    char joined[512];
    std_memcpy(joined, zig_lib_dir, zig_lib_dir_len);
    size_t len = zig_lib_dir_len;
    joined[len++] = '/';
    std_memcpy(joined + len, "zig.h", 5);
    joined[len] = 0;

    cg->zig_h = std_readFile(joined, &cg->zig_h_len);
    if (!cg->zig_h) std_panic(NULL, "failed to open %s/zig.h\n", zig_lib_dir);
}

#define emit(fmt, ...) std_fprintf(cg->out, fmt, ## __VA_ARGS__)
#define indent() std_fprintf(cg->out, "%*c", 4 * cg->indent, ' ');

static void CodeGen_emitPrologue(CodeGen *cg)
{
    emit("/* Generated by tzc */\n");
#ifdef USE_ZIG_H
    emit("\n");
    emit("#define ZIG_TARGET_MAX_INT_ALIGNMENT 16\n");
    emit("/* zig.h begin */\n");
    std_writeFile(cg->zig_h, cg->zig_h_len, 1, cg->out);
    emit("/* zig.h end */\n");
    emit("\n");
#else
    emit("#include <stddef.h>\n");
    emit("#include <stdbool.h>\n");
    emit("#include <stdint.h>\n");
    emit("\n");
#endif
}

static void CodeGen_emitFuncDecl(CodeGen *cg, IrFunc *func)
{
    emit("int "PRIb"(", Buffer(func->name));

    if (func->call_args.len == 0) {
        emit("void");
    } else {
        for (uint32_t i = 0; i < func->call_args.len; i++) {
            IrNamedType ty = func->call_args.data[i];
            if (!ty.is_varargs) {
                Buffer resolved_ty = Sema_evalTypeName(ty.type);
                emit(PRIb" "PRIb, Buffer(resolved_ty), Buffer(ty.name));
            } else {
                emit("...");
            }
            if (i + 1 < func->call_args.len) emit(", ");
        }
    }
    emit(")");
}

static void CodeGen_emitInst(CodeGen *cg, IrInst inst)
{
    indent();

    switch (inst.op) {
        case ir_op_call:
            // TODO: pass through fn name lazily
            emit("int t%d = "PRIb"(", inst.dst, Buffer(inst.data.call.fn.data.sym));
            for (uint8_t i = 0; i < inst.data.call.args_len; i++) {
                emit("t%d", inst.data.call.args[i]);
                if (i + 1 < inst.data.call.args_len) emit(",");
            }
            emit(");\n");
            break;

        case ir_op_copy:
            emit("t%d = t%d;\n", inst.dst, inst.data.unary.lhs);
            break;

        case ir_op_negate:
            emit("int t%d = -t%d;\n", inst.dst, inst.data.unary.lhs);
            break;
        case ir_op_bw_not:
            emit("int t%d = ~t%d;\n", inst.dst, inst.data.unary.lhs);
            break;
        case ir_op_bw_and:
            emit("int t%d = &t%d;\n", inst.dst, inst.data.unary.lhs);
            break;
        case ir_op_not:
            emit("int t%d = !t%d;\n", inst.dst, inst.data.unary.lhs);
            break;

        case ir_op_const_num:
        case ir_op_const_char:
            emit("int t%d = %lld;\n", inst.dst, inst.data.i64);
            break;

        case ir_op_store_var:
            emit("v%d = t%d;\n", inst.data.var.id, inst.data.var.value);
            break;
        case ir_op_load_var:
            emit("int t%d = v%d;\n", inst.dst, inst.data.var.id);
            break;

        case ir_op_load_arg:
            emit("v%d = "PRIb";\n", inst.data.arg.id, Buffer(inst.data.arg.name));
            break;

        case ir_op_const_bytes:
            // bytes includes quotations from tokenizer
            emit("char *t%d = "PRIb";\n", inst.dst, Buffer(inst.data.bytes));
            break;

        case ir_op_or:
            emit("int t%d = t%d || t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_and:
            emit("int t%d = t%d && t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_eq:
            emit("int t%d = t%d == t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_neq:
            emit("int t%d = t%d != t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_lt:
            emit("int t%d = t%d < t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_gt:
            emit("int t%d = t%d > t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_lte:
            emit("int t%d = t%d <= t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_gte:
            emit("int t%d = t%d >= t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_bit_and:
            emit("int t%d = t%d & t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_bit_xor:
            emit("int t%d = t%d ^ t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_shl:
            emit("int t%d = t%d << t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_shr:
            emit("int t%d = t%d >> t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_add:
            emit("int t%d = t%d + t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_sub:
            emit("int t%d = t%d - t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_mul:
            emit("int t%d = t%d * t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_div:
            emit("int t%d = t%d / t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_mod:
            emit("int t%d = t%d % t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;

        default:
            break;
    }
}

static void CodeGen_emitTerm(CodeGen *cg, IrTerm term)
{
    indent();
    switch (term.tag) {
        case ir_term_br:
            emit("if (t%d) { goto b%d; } else { goto b%d; }\n",
                term.data.br.cond, term.data.br.t, term.data.br.f);
            break;

        case ir_term_jmp:
            emit("goto b%d;\n", term.data.jmp.target);
            break;

        case ir_term_ret:
            emit("return t%d;\n", term.data.ret.value);
        case ir_term_next:
            break;
    }
}

static void CodeGen_emitBlock(CodeGen *cg, IrBlockId id, IrBlock *block)
{
    // we sometimes emit an empty jump target, omit these (maybe add back in
    // if this is used as a target).
    //if (block->insts.len == 0 && block->term.tag == ir_term_next) return;

    emit("b%d:;\n", id);
    for (uint32_t i = 0; i < block->insts.len; i++) {
        CodeGen_emitInst(cg, block->insts.data[i]);
    }
    CodeGen_emitTerm(cg, block->term);
}

static void CodeGen_emitFuncDef(CodeGen *cg, IrFunc *func)
{
    CodeGen_emitFuncDecl(cg, func);
    emit("\n{\n");

    for (uint32_t i = 0; i < func->vars.len; i++) {
        indent();
        emit("int v%d; // "PRIb"\n", i, Buffer(func->vars.data[i].name));
    }

    for (uint32_t i = 0; i < func->blocks.len; i++) {
        CodeGen_emitBlock(cg, i, func->blocks.data[i]);
    }

    emit("}\n\n");
}

static void CodeGen_emitModule(CodeGen *cg, IrProgram *ir)
{
    CodeGen_emitPrologue(cg);

    for (uint32_t i = 0; i < ir->funcs.len; i++) {
        CodeGen_emitFuncDecl(cg, ir->funcs.data[i]);
        emit(";\n");
    }
    emit("\n");

    for (uint32_t i = 0; i < ir->funcs.len; i++) {
        if ((ir->funcs.data[i]->modifiers & decl_modifier_extern) != 0) {
            continue;
        }

        CodeGen_emitFuncDef(cg, ir->funcs.data[i]);
    }
}

static void CodeGen_gen(CodeGen *cg, IrProgram *ir)
{
    CodeGen_emitModule(cg, ir);
}

#undef emit
#undef indent