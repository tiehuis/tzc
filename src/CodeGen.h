typedef struct {
    void *out;
    const char *output_filename;
    const char *zig_lib_dir;
    uint8_t indent;
    CompileContext *ctx;

    char *zig_h;
    long zig_h_len;
} CodeGen;

static void CodeGen_init(CodeGen *cg, CompileContext *ctx, const char *output_filename, const char *zig_lib_dir)
{
    cg->ctx = ctx;
    cg->out = std_createFile(output_filename);
    cg->indent = 0;
    if (!cg->out) std_panic(NULL, "failed to fopen output\n");

    size_t zig_lib_dir_len = std_strlen(zig_lib_dir);
    assume(zig_lib_dir_len + 1 + 5 + 1 < 512);

    char joined[512];
    std_memcpy(joined, zig_lib_dir, zig_lib_dir_len);
    size_t len = zig_lib_dir_len;
    joined[len++] = '/';
    std_memcpy(joined + len, "zig.h", 5);
    joined[len] = 0;

    cg->zig_h = std_readFile(joined, &cg->zig_h_len);
    if (!cg->zig_h) std_panic(NULL, "failed to open %s\n", joined);
}

#define emit(fmt, ...) std_fprintf(cg->out, fmt, ## __VA_ARGS__)
#define indent() std_fprintf(cg->out, "%*c", 4 * cg->indent, ' ');
#define Buf(_b) Buffer(CompileContext_getString(cg->ctx, (_b)))

static void CodeGen_emitPrologue(CodeGen *cg)
{
    emit("/* Generated by tzc */\n");
#ifdef USE_ZIG_H
    emit("\n");
    emit("#define ZIG_TARGET_MAX_INT_ALIGNMENT 16\n");
    emit("/* zig.h begin */\n");
    std_writeFile(cg->zig_h, cg->zig_h_len, 1, cg->out);
    emit("/* zig.h end */\n");
    emit("\n");
#else
    emit("#include <stddef.h>\n");
    emit("#include <stdbool.h>\n");
    emit("#include <stdint.h>\n");
    emit("\n");
#endif
}

static void CodeGen_emitType(CodeGen *cg, tInternId id)
{
    tType ty = CompileContext_getType(cg->ctx, id);
    switch (ty.tag) {
        case ty_anyopaque:
            emit("void");
            break;
        case ty_bool:
            emit("_Bool");
            break;
        case ty_u8:
            emit("uint8_t");
            break;
        case ty_u16:
            emit("uint16_t");
            break;
        case ty_u32:
            emit("uint32_t");
            break;
        case ty_u64:
            emit("uint64_t");
            break;
        case ty_u128:
            emit("unsigned __int128");
            break;
        case ty_i8:
            emit("int8_t");
            break;
        case ty_i16:
            emit("int16_t");
            break;
        case ty_i32:
            emit("int32_t");
            break;
        case ty_i64:
            emit("int64_t");
            break;
        case ty_i128:
            emit("int128_t");
            break;
        case ty_isize:
            emit("ssize_t");
            break;
        case ty_usize:
            emit("size_t");
            break;
        case ty_c_char:
            emit("char");
            break;
        case ty_c_short:
            emit("short");
            break;
        case ty_c_ushort:
            emit("unsigned short");
            break;
        case ty_c_int:
            emit("int");
            break;
        case ty_c_uint:
            emit("unsigned int");
            break;
        case ty_c_long:
            emit("long");
            break;
        case ty_c_ulong:
            emit("unsigned long");
            break;
        case ty_c_longlong:
            emit("long long");
            break;
        case ty_c_ulonglong:
            emit("unsigned long long");
            break;
        case ty_c_longdouble:
            emit("long double");
            break;
        case ty_f16:
            emit("_Float16");
            break;
        case ty_f32:
            emit("float");
            break;
        case ty_f64:
            emit("double");
            break;
        case ty_f80:
            emit("long double");
            break;
        case ty_f128:
            emit("__Float128");
            break;
        // complex
        case ty_ptr_one:
            if ((ty.data.ptr.modifiers & pointer_modifier_const) != 0) emit("const ");
            CodeGen_emitType(cg, ty.data.ptr.child);
            emit("*");
            break;
        case ty_ptr_two:
            if ((ty.data.ptr.modifiers & pointer_modifier_const) != 0) emit("const ");
            CodeGen_emitType(cg, ty.data.ptr.child);
            emit("**");
            break;
        default:
            assume(false);
    }
}

static void CodeGen_emitFuncDecl(CodeGen *cg, IrFunc *func)
{
    emit("int "PRIb"(", Buf(func->name));

    if (func->call_args.len == 0) {
        emit("void");
    } else {
        for (uint32_t i = 0; i < func->call_args.len; i++) {
            IrNamedType ty = func->call_args.data[i];
            if (!ty.is_varargs) {
                CodeGen_emitType(cg, ty.type);
                emit(" "PRIb, Buf(ty.name));
            } else {
                emit("...");
            }
            if (i + 1 < func->call_args.len) emit(", ");
        }
    }
    emit(")");
}

static void CodeGen_emitInst(CodeGen *cg, IrFunc *func, IrInst inst)
{
    indent();

    IrTemp dst;
    if (IrOp_hasDst(inst.op)) dst = func->temps.data[inst.dst];

    switch (inst.op) {
        case ir_op_call:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = "PRIb"(", inst.dst, Buffer(CompileContext_getString(cg->ctx, inst.data.call.fn.data.sym)));
            for (uint8_t i = 0; i < inst.data.call.args_len; i++) {
                emit("t%d", inst.data.call.args[i]);
                if (i + 1 < inst.data.call.args_len) emit(",");
            }
            emit(");\n");
            break;

        case ir_op_copy:
            emit("t%d = t%d;\n", inst.dst, inst.data.unary.lhs);
            break;

        case ir_op_negate:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = -t%d;\n", inst.dst, inst.data.unary.lhs);
            break;
        case ir_op_bw_not:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = ~t%d;\n", inst.dst, inst.data.unary.lhs);
            break;
        case ir_op_bw_and:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = &t%d;\n", inst.dst, inst.data.unary.lhs);
            break;
        case ir_op_not:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = !t%d;\n", inst.dst, inst.data.unary.lhs);
            break;

        case ir_op_const_num:
        case ir_op_const_char:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = %lld;\n", inst.dst, inst.data.i64);
            break;

        case ir_op_store_var:
            emit("v%d = t%d;\n", inst.data.var.id, inst.data.var.value);
            break;
        case ir_op_load_var:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = v%d;\n", inst.dst, inst.data.var.id);
            break;

        case ir_op_load_arg:
            emit("v%d = "PRIb";\n", inst.data.arg.id, Buf(inst.data.arg.name));
            break;

        case ir_op_const_bytes:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = "PRIb";\n", inst.dst, Buf(inst.data.bytes));
            break;

        case ir_op_or:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d || t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_and:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d && t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_eq:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d == t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_neq:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d != t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_lt:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d < t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_gt:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d > t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_lte:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d <= t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_gte:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d >= t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_bit_and:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d & t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_bit_xor:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d ^ t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_shl:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d << t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_shr:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d >> t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_add:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d + t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_sub:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d - t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_mul:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d * t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_div:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d / t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;
        case ir_op_mod:
            CodeGen_emitType(cg, dst.type);
            emit(" t%d = t%d % t%d;\n", inst.dst, inst.data.binary.lhs, inst.data.binary.rhs);
            break;

        default:
            break;
    }
}

static void CodeGen_emitTerm(CodeGen *cg, IrTerm term)
{
    indent();
    switch (term.tag) {
        case ir_term_br:
            emit("if (t%d) { goto b%d; } else { goto b%d; }\n",
                term.data.br.cond, term.data.br.t, term.data.br.f);
            break;

        case ir_term_jmp:
            emit("goto b%d;\n", term.data.jmp.target);
            break;

        case ir_term_ret:
            emit("return t%d;\n", term.data.ret.value);
        case ir_term_next:
            break;
    }
}

static void CodeGen_emitBlock(CodeGen *cg, IrFunc *func, IrBlockId id, IrBlock *block)
{
    // jump targets can be empty, hence emit an empty statement unconditionally
    emit("b%d:;\n", id);
    for (uint32_t i = 0; i < block->insts.len; i++) {
        CodeGen_emitInst(cg, func, block->insts.data[i]);
    }
    CodeGen_emitTerm(cg, block->term);
}

static void CodeGen_emitFuncDef(CodeGen *cg, IrFunc *func)
{
    CodeGen_emitFuncDecl(cg, func);
    emit("\n{\n");

    for (uint32_t i = 0; i < func->vars.len; i++) {
        indent();
        CodeGen_emitType(cg, func->vars.data[i].type);
        emit(" v%d; // "PRIb"\n", i, Buf(func->vars.data[i].name));
    }

    for (uint32_t i = 0; i < func->blocks.len; i++) {
        CodeGen_emitBlock(cg, func, i, func->blocks.data[i]);
    }

    emit("}\n\n");
}

static void CodeGen_emitModule(CodeGen *cg, IrProgram *ir)
{
    CodeGen_emitPrologue(cg);

    for (uint32_t i = 0; i < ir->funcs.len; i++) {
        CodeGen_emitFuncDecl(cg, ir->funcs.data[i]);
        emit(";\n");
    }
    emit("\n");

    for (uint32_t i = 0; i < ir->funcs.len; i++) {
        if ((ir->funcs.data[i]->modifiers & decl_modifier_extern) != 0) {
            continue;
        }

        CodeGen_emitFuncDef(cg, ir->funcs.data[i]);
    }
}

static void CodeGen_gen(CodeGen *cg, IrProgram *ir)
{
    CodeGen_emitModule(cg, ir);
}

#undef emit
#undef indent
#undef Buf